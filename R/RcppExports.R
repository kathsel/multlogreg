# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate the multivariate logistic density of a vector
#'
#' @param x numeric vector containing the random numbers
#' @param mean numeric vector
#' @param R numeric scale matrix with 1's on the diagonal
#' @param df degrees of freedom
#' @param logd boolean indicating whether the log-transformed density
#'   should be returned
dmvlogis <- function(x, mean, R, df = 7.3, logd = FALSE) {
    .Call(`_multlogreg_dmvlogis`, x, mean, R, df, logd)
}

#' Calculate the multivariate normal density of a vector
#'
#' @param x numeric vector containing the random numbers
#' @param mean numeric vector
#' @param sigma numeric covariance matrix
#' @param logd boolean indicating whether the log-transformed density
#'   should be returned
dmvnrm <- function(x, mean, sigma, logd = FALSE) {
    .Call(`_multlogreg_dmvnrm`, x, mean, sigma, logd)
}

#' Calculate the multivariate Student t density of a vector
#'
#' @param x numeric vector containing the random numbers
#' @param mean numeric vector
#' @param sigma numeric covariance matrix
#' @param df degrees of freedom
#' @param logd boolean indicating whether the log-transformed density
#'   should be returned
dmvt <- function(x, mean, sigma, df, logd = FALSE) {
    .Call(`_multlogreg_dmvt`, x, mean, sigma, df, logd)
}

#' Fit the multivariate logistic regression model with Gibbs sampling
#'
#' @param x numeric array containing the covariates for each sample
#' @param y numeric matrix containing the outcomes of interest
#' @param iter integer, the number of iterartions
#' @param beta0 intial values for the coefficients
#' @param r0 initial values for the unique entries of the scale matrix
#' @param phi0 initial values for phis
#' @param mubeta prior mean on beta
#' @param sigbeta prior covariance matrix for beta
#' @param omega variance-covariance matrix for sampling r (Metropolis step)
#' @param burn_in number of burn in samples to use for complete loop
#' @param thinning thinning used
#' @param burn_in_truncated number of burn in samples to use for sampling from
#'   the truncated normal distribution
#'
cmvlr <- function(x, y, iter, beta0, r0, phi0, mubeta, sigbeta, omega, burn_in, thinning, burn_in_truncated = 10L) {
    .Call(`_multlogreg_cmvlr`, x, y, iter, beta0, r0, phi0, mubeta, sigbeta, omega, burn_in, thinning, burn_in_truncated)
}

#' Generate samples from a truncated multivariate normal distribution
#'
#' Generates a n x q matrix with n samples of a truncated multivariate
#' normal distribution with dimension q using the acceptance-rejection method
#' sampling from a multivariate normal distribution.
#'
#' For the a non-diagonal matrix D, the linear restriction lower <= Dx <= upper
#' hold.
#'
#' @param n number of samples to be generated
#' @param mean mean vector (q x 1)
#' @param sigma covariance matrix (q x q)
#' @param D matrix of linear constraints
#' @param lower vector of lower bounds
#' @param upper vector of upper bounds
#' @param nproposals number of propsal samples per iteration
#' @param verbose should information about sampling be printed?
rtmvn_accrej <- function(n, mean, sigma, D, lower, upper, nproposals = 0L, verbose = FALSE) {
    .Call(`_multlogreg_rtmvn_accrej`, n, mean, sigma, D, lower, upper, nproposals, verbose)
}

#' Gibbs sampler for the Truncated Multivariate Normal Distribution
#'
#' Random vector generation for the truncated multivariate normal distribution
#'     using a Gibbs sampler.
#'
#' @param n number of samples to be generated
#' @param mean mean vector
#' @param sigma covariance matrix
#' @param D matrix of linear constraints
#' @param lower vector of lower bounds
#' @param upper vector of upper bounds
#' @param init vector of initial values for the Gibbs sampler.
#' @param burn_in number of burn in samples to use.
#' @param thinning thinning parameter
#'
#' @return matrix of samples with each column being an idependent sample.
#'
#' @references Li, Y., & Ghosh, S. K. (2015). Efficient sampling methods for
#'     truncated multivariate normal and student-t distributions subject to
#'     linear inequality constraints. Journal of Statistical Theory and
#'     Practice, 9(4), 712-732.
#' @export
rtmvn_gibbs <- function(n, mean, sigma, D, lower, upper, init, burn_in = 10L, thinning = 1L) {
    .Call(`_multlogreg_rtmvn_gibbs`, n, mean, sigma, D, lower, upper, init, burn_in, thinning)
}

#' Univariate Truncated Normal Distribution
#'
#' Generates n samples from the truncated normal distribution
#'  TN(mean, sd; lower, upper).
#'
#' @param n number of samples
#' @param mean mean
#' @param sd standard deviation
#' @param lower lower bound
#' @param upper upper bound
#' @return vector of n samples
#'
#' @references Li, Y., & Ghosh, S. K. (2015). Efficient sampling methods for
#'     truncated multivariate normal and student-t distributions subject to
#'     linear inequality constraints. Journal of Statistical Theory and
#'     Practice, 9(4), 712-732.
#'
#' @examples
#' rtuvn(n = 1, mean = 10, sd = 20, lower = 10, upper = 20)
#' rtuvn(n = 1, mean = 10, sd = 20, lower = 10, upper = Inf)
#'
#' @export
rtuvn <- function(n, mean, sd, lower, upper) {
    .Call(`_multlogreg_rtuvn`, n, mean, sd, lower, upper)
}

#' Univariate Truncated Normal Distribution - single sample
#'
#' Generate one sample from the truncated normal distribution
#'  TN(mean, sd; lower, upper).
rtuvn_single <- function(mean, sd, lower, upper) {
    .Call(`_multlogreg_rtuvn_single`, mean, sd, lower, upper)
}

